# Go

如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。

range 和 make 可作用于切片和映射

在结构体和映射后可用{}初始化

```Go
var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}
```

Go 没有类。不过你可以为结构体类型（或结构体类型）定义方法。方法就是一类带特殊的接收者参数的函数。接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。

指针接收者的方法可以修改接收者指向的值。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。

对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&v).Scale(5)。

接口类型 是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。

即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它。

指定了零个方法的接口值被称为空接口：`interface{}`。空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）空接口被用来处理未知类型的值

比较结构体是否相等

```GO
type Vertex struct {
	str string
	X int
	Y int
}

func main() {
	a := Vertex{
		str:	"ab",
		X:		1,
		Y:		2,
	}
	b := Vertex{
		str:	"ab",
		X:		1,
		Y:		2,
	}
	fmt.Println(a == b) //true
}
```
